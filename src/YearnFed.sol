pragma solidity ^0.8.13;

import "IYearnVault.sol";
import "IERC20.sol";

contract YearnFed{

    IYearnVault public vault;
    IERC20 public underlying;
    address public chair; // Fed Chair
    address public gov;
    uint public supply;
    uint public maxLossBpContraction;
    uint public maxLossBpTakeProfit;

    event Expansion(uint amount);
    event Contraction(uint amount);

    constructor(IYearnVault vault_, address gov_, uint maxLossBpContraction_, uint maxLossBpTakeProfit_) {
        vault = vault_;
        underlying = IERC20(vault_.token());
        underlying.approve(address(vault), type(uint256).max);
        chair = msg.sender;
        maxLossBpContraction = maxLossBpContraction_;
        maxLossBpTakeProfit = maxLossBpTakeProfit_;
        gov = gov_;
    }

    /**
    @notice Method for gov to change gov address
    */
    function changeGov(address newGov_) public {
        require(msg.sender == gov, "ONLY GOV");
        gov = newGov_;
    }

    /**
    @notice Method for gov to change the chair
    */
    function changeChair(address newChair_) public {
        require(msg.sender == gov, "ONLY GOV");
        chair = newChair_;
    }
    /**
    @notice Method for governance to set max loss in basis points, when withdraing from yearn vault
    @param newMaxLossBpContraction new maximally allowed loss in Bp 1 = 0.01%
    */
    function setMaxLossBpContraction(uint newMaxLossBpContraction) public {
        require(msg.sender == gov, "ONLY GOV");
        require(newMaxLossBpContraction <= 10000);
        maxLossBpContraction = newMaxLossBpContraction;
    }

    /**
    @notice Method for governance to set max loss in basis points, when taking profit from yearn vault
    @param newMaxLossBpTakeProfit new maximally allowed loss in Bp 1 = 0.001%
    */
    function setMaxLossBpTakeProfit(uint newMaxLossBpTakeProfit) public {
        require(msg.sender == gov, "ONLY GOV");
        require(newMaxLossBpTakeProfit <= 100000);
        maxLossBpTakeProfit = newMaxLossBpTakeProfit;
    }

    /**
    @notice Method for withdrawing any token from the contract to governance. Should only be used in emergencies.
    @param token Address of token contract to withdraw to gov
    @param amount Amount of tokens to withdraw
    */
    function emergencyWithdraw(address token, uint amount) public{
        require(msg.sender == gov, "ONLY GOV");
        IERC20(token).transfer(gov, amount);
    }

    /**
    @notice Method for current chair of the Yearn FED to resign
    */
    function resign() public {
        require(msg.sender == chair, "ONLY CHAIR");
        chair = address(0);
    }

    /**
    @notice Deposits amount of underlying tokens into yEarn vault

    @param amount Amount of underlying token to deposit into yEarn vault
    */
    function expansion(uint amount) public {
        require(msg.sender == chair, "ONLY CHAIR");
        //Alternatively set amount to max uint if over deposit limit,
        //as that supplies greatest possible amount into vault
        /*
        if( amount > _maxDeposit()){
            amount = type(uint256).max;
        }
        */
        require(amount <= _maxDeposit(), "AMOUNT TOO BIG"); // can't deploy more than max
        underlying.mint(address(this), amount);
        uint shares = vault.deposit(amount, address(this));
        require(shares == 0, 'Supplying failed'); //Probably an unnecessary require
        supply = supply + amount;
        emit Expansion(amount);
    }

    /**
    @notice Withdraws an amount of underlying token to be burnt, contracting DOLA supply
    
    @dev Its recommended to always broadcast withdrawl transactions(contraction & takeProfits)
    through a frontrun protected RPC like Flashbots RPC.
    
    @param amount The amount of underlying tokens to withdraw. Note that more tokens may
    be withdrawn than requested, as price is calculated by debts to strategies, but strategies
    may have outperformed price of underlying token.
    */
    function contraction(uint amount) public {
        require(msg.sender == chair, "ONLY CHAIR");
        uint underlyingWithdrawn = _withdrawAmountUnderlying(amount, maxLossBpContraction);
        require(underlyingWithdrawn <= supply, "AMOUNT TOO BIG"); // can't burn profits
        require(underlyingWithdrawn > 0, "NOTHING WITHDRAWN");
        underlying.burn(underlyingWithdrawn);
        supply = supply - amount;
        emit Contraction(underlyingWithdrawn);
    }

    /**
    @notice Withdraws the profit generated by yEarn vault

    @dev See dev note on Contraction method
    */
    function takeProfit() public {
        uint expectedBalance = vault.balanceOf(address(this))*vault.pricePerShare()/10**vault.decimals();
        if(expectedBalance > supply){
            uint expectedProfit = expectedBalance - supply;
            if(expectedProfit > 0) {
                uint actualProfit = _withdrawAmountUnderlying(expectedProfit, maxLossBpTakeProfit);
                require(actualProfit > 0, "NO PROFIT");
                underlying.transfer(gov, actualProfit);
            }
        }
    }

    /**
    @notice calculates the amount of shares needed for withdrawing amount of underlying, and withdraws that amount.

    @dev See dev note on Contraction method

    @param amount The amount of underlying tokens to withdraw.
    @param maxLossBp The maximally acceptable loss in basis points. 1 = 0.001%
    */
    function _withdrawAmountUnderlying(uint amount, uint maxLossBp) internal returns (uint){
        uint sharesNeeded = amount*10**vault.decimals()/vault.pricePerShare();
        return vault.withdraw(sharesNeeded, address(this), maxLossBp);
    }

    /**
    @notice calculates the maximum possible deposit for the yearn vault
    */
    function _maxDeposit() view internal returns (uint) {
        return vault.depositLimit() - vault.totalDebt() - underlying.balanceOf(address(vault));
    }
    
}
